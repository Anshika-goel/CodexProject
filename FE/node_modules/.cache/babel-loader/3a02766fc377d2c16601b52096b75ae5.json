{"ast":null,"code":"var _objectWithoutProperties = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _toConsumableArray = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _get = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _possibleConstructorReturn = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _objectSpread = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sakshatgandhi/Desktop/CodexProject/FE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"react\"), require(\"use-sync-external-store/shim\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\", \"use-sync-external-store/shim\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).ReactQuery = {}, t.React, t.shim);\n}(this, function (t, e, s) {\n  \"use strict\";\n\n  function r(t) {\n    if (t && t.__esModule) return t;\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (s) {\n      if (\"default\" !== s) {\n        var r = Object.getOwnPropertyDescriptor(t, s);\n        Object.defineProperty(e, s, r.get ? r : {\n          enumerable: !0,\n          get: function get() {\n            return t[s];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n\n  var i = r(e);\n  /**\n     * query-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n\n  var n = /*#__PURE__*/function () {\n    function n() {\n      _classCallCheck(this, n);\n\n      this.listeners = [], this.subscribe = this.subscribe.bind(this);\n    }\n\n    _createClass(n, [{\n      key: \"subscribe\",\n      value: function subscribe(t) {\n        var _this = this;\n\n        return this.listeners.push(t), this.onSubscribe(), function () {\n          _this.listeners = _this.listeners.filter(function (e) {\n            return e !== t;\n          }), _this.onUnsubscribe();\n        };\n      }\n    }, {\n      key: \"hasListeners\",\n      value: function hasListeners() {\n        return this.listeners.length > 0;\n      }\n    }, {\n      key: \"onSubscribe\",\n      value: function onSubscribe() {}\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {}\n    }]);\n\n    return n;\n  }();\n\n  var a = \"undefined\" == typeof window;\n\n  function o() {}\n\n  function u(t) {\n    return \"number\" == typeof t && t >= 0 && t !== 1 / 0;\n  }\n\n  function c(t, e) {\n    return t.filter(function (t) {\n      return -1 === e.indexOf(t);\n    });\n  }\n\n  function h(t, e) {\n    return Math.max(t + (e || 0) - Date.now(), 0);\n  }\n\n  function l(t, e, s) {\n    return S(t) ? \"function\" == typeof e ? _objectSpread({}, s, {\n      queryKey: t,\n      queryFn: e\n    }) : _objectSpread({}, e, {\n      queryKey: t\n    }) : t;\n  }\n\n  function d(t, e, s) {\n    return S(t) ? \"function\" == typeof e ? _objectSpread({}, s, {\n      mutationKey: t,\n      mutationFn: e\n    }) : _objectSpread({}, e, {\n      mutationKey: t\n    }) : \"function\" == typeof t ? _objectSpread({}, e, {\n      mutationFn: t\n    }) : _objectSpread({}, t);\n  }\n\n  function f(t, e, s) {\n    return S(t) ? [_objectSpread({}, e, {\n      queryKey: t\n    }), s] : [t || {}, e];\n  }\n\n  function p(t, e, s) {\n    return S(t) ? [_objectSpread({}, e, {\n      mutationKey: t\n    }), s] : [t || {}, e];\n  }\n\n  function y(t, e) {\n    var _t$type = t.type,\n        s = _t$type === void 0 ? \"all\" : _t$type,\n        r = t.exact,\n        i = t.fetchStatus,\n        n = t.predicate,\n        a = t.queryKey,\n        o = t.stale;\n    if (S(a)) if (r) {\n      if (e.queryHash !== m(a, e.options)) return !1;\n    } else if (!g(e.queryKey, a)) return !1;\n\n    if (\"all\" !== s) {\n      var _t = e.isActive();\n\n      if (\"active\" === s && !_t) return !1;\n      if (\"inactive\" === s && _t) return !1;\n    }\n\n    return (\"boolean\" != typeof o || e.isStale() === o) && (void 0 === i || i === e.state.fetchStatus) && !(n && !n(e));\n  }\n\n  function v(t, e) {\n    var s = t.exact,\n        r = t.fetching,\n        i = t.predicate,\n        n = t.mutationKey;\n\n    if (S(n)) {\n      if (!e.options.mutationKey) return !1;\n\n      if (s) {\n        if (b(e.options.mutationKey) !== b(n)) return !1;\n      } else if (!g(e.options.mutationKey, n)) return !1;\n    }\n\n    return (\"boolean\" != typeof r || \"loading\" === e.state.status === r) && !(i && !i(e));\n  }\n\n  function m(t, e) {\n    return ((null == e ? void 0 : e.queryKeyHashFn) || b)(t);\n  }\n\n  function b(t) {\n    return JSON.stringify(t, function (t, e) {\n      return q(e) ? Object.keys(e).sort().reduce(function (t, s) {\n        return t[s] = e[s], t;\n      }, {}) : e;\n    });\n  }\n\n  function g(t, e) {\n    return O(t, e);\n  }\n\n  function O(t, e) {\n    return t === e || typeof t == typeof e && !(!t || !e || \"object\" != typeof t || \"object\" != typeof e) && !Object.keys(e).some(function (s) {\n      return !O(t[s], e[s]);\n    });\n  }\n\n  function C(t, e) {\n    if (t === e) return t;\n    var s = R(t) && R(e);\n\n    if (s || q(t) && q(e)) {\n      var _r = s ? t.length : Object.keys(t).length,\n          _i = s ? e : Object.keys(e),\n          _n = _i.length,\n          _a = s ? [] : {};\n\n      var _o = 0;\n\n      for (var _r2 = 0; _r2 < _n; _r2++) {\n        var _n2 = s ? _r2 : _i[_r2];\n\n        _a[_n2] = C(t[_n2], e[_n2]), _a[_n2] === t[_n2] && _o++;\n      }\n\n      return _r === _n && _o === _r ? t : _a;\n    }\n\n    return e;\n  }\n\n  function R(t) {\n    return Array.isArray(t) && t.length === Object.keys(t).length;\n  }\n\n  function q(t) {\n    if (!P(t)) return !1;\n    var e = t.constructor;\n    if (void 0 === e) return !0;\n    var s = e.prototype;\n    return !!P(s) && !!s.hasOwnProperty(\"isPrototypeOf\");\n  }\n\n  function P(t) {\n    return \"[object Object]\" === Object.prototype.toString.call(t);\n  }\n\n  function S(t) {\n    return Array.isArray(t);\n  }\n\n  function Q(t) {\n    return new Promise(function (e) {\n      setTimeout(e, t);\n    });\n  }\n\n  function E(t) {\n    Q(0).then(t);\n  }\n\n  function x(t, e, s) {\n    return null != s.isDataEqual && s.isDataEqual(t, e) ? t : !1 !== s.structuralSharing ? C(t, e) : e;\n  }\n\n  var M = new ( /*#__PURE__*/function (_n3) {\n    _inherits(_class, _n3);\n\n    function _class() {\n      var _this2;\n\n      _classCallCheck(this, _class);\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this)), _this2.setup = function (t) {\n        if (!a && window.addEventListener) {\n          var _e = function _e() {\n            return t();\n          };\n\n          return window.addEventListener(\"visibilitychange\", _e, !1), window.addEventListener(\"focus\", _e, !1), function () {\n            window.removeEventListener(\"visibilitychange\", _e), window.removeEventListener(\"focus\", _e);\n          };\n        }\n      };\n      return _this2;\n    }\n\n    _createClass(_class, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        this.cleanup || this.setEventListener(this.setup);\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n      }\n    }, {\n      key: \"setEventListener\",\n      value: function setEventListener(t) {\n        var _this3 = this;\n\n        var e;\n        this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(function (t) {\n          \"boolean\" == typeof t ? _this3.setFocused(t) : _this3.onFocus();\n        });\n      }\n    }, {\n      key: \"setFocused\",\n      value: function setFocused(t) {\n        this.focused = t, t && this.onFocus();\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        this.listeners.forEach(function (t) {\n          t();\n        });\n      }\n    }, {\n      key: \"isFocused\",\n      value: function isFocused() {\n        return \"boolean\" == typeof this.focused ? this.focused : \"undefined\" == typeof document || [void 0, \"visible\", \"prerender\"].includes(document.visibilityState);\n      }\n    }]);\n\n    return _class;\n  }(n))();\n  var w = new ( /*#__PURE__*/function (_n4) {\n    _inherits(_class2, _n4);\n\n    function _class2() {\n      var _this4;\n\n      _classCallCheck(this, _class2);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this)), _this4.setup = function (t) {\n        if (!a && window.addEventListener) {\n          var _e2 = function _e2() {\n            return t();\n          };\n\n          return window.addEventListener(\"online\", _e2, !1), window.addEventListener(\"offline\", _e2, !1), function () {\n            window.removeEventListener(\"online\", _e2), window.removeEventListener(\"offline\", _e2);\n          };\n        }\n      };\n      return _this4;\n    }\n\n    _createClass(_class2, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        this.cleanup || this.setEventListener(this.setup);\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n      }\n    }, {\n      key: \"setEventListener\",\n      value: function setEventListener(t) {\n        var _this5 = this;\n\n        var e;\n        this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(function (t) {\n          \"boolean\" == typeof t ? _this5.setOnline(t) : _this5.onOnline();\n        });\n      }\n    }, {\n      key: \"setOnline\",\n      value: function setOnline(t) {\n        this.online = t, t && this.onOnline();\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        this.listeners.forEach(function (t) {\n          t();\n        });\n      }\n    }, {\n      key: \"isOnline\",\n      value: function isOnline() {\n        return \"boolean\" == typeof this.online ? this.online : \"undefined\" == typeof navigator || void 0 === navigator.onLine || navigator.onLine;\n      }\n    }]);\n\n    return _class2;\n  }(n))();\n\n  function F(t) {\n    return Math.min(1e3 * Math.pow(2, t), 3e4);\n  }\n\n  function A(t) {\n    return \"online\" !== (null != t ? t : \"online\") || w.isOnline();\n  }\n\n  var D = function D(t) {\n    _classCallCheck(this, D);\n\n    this.revert = null == t ? void 0 : t.revert, this.silent = null == t ? void 0 : t.silent;\n  };\n\n  function I(t) {\n    return t instanceof D;\n  }\n\n  function U(t) {\n    var e,\n        s,\n        r,\n        i = !1,\n        n = 0,\n        a = !1;\n\n    var o = new Promise(function (t, e) {\n      s = t, r = e;\n    }),\n        u = function u() {\n      return !M.isFocused() || \"always\" !== t.networkMode && !w.isOnline();\n    },\n        c = function c(r) {\n      a || (a = !0, null == t.onSuccess || t.onSuccess(r), null == e || e(), s(r));\n    },\n        h = function h(s) {\n      a || (a = !0, null == t.onError || t.onError(s), null == e || e(), r(s));\n    },\n        l = function l() {\n      return new Promise(function (s) {\n        e = function e(t) {\n          if (a || !u()) return s(t);\n        }, null == t.onPause || t.onPause();\n      }).then(function () {\n        e = void 0, a || null == t.onContinue || t.onContinue();\n      });\n    },\n        d = function d() {\n      if (a) return;\n      var e;\n\n      try {\n        e = t.fn();\n      } catch (t) {\n        e = Promise.reject(t);\n      }\n\n      Promise.resolve(e).then(c).catch(function (e) {\n        var s, r;\n        if (a) return;\n        var o = null != (s = t.retry) ? s : 3,\n            c = null != (r = t.retryDelay) ? r : F,\n            f = \"function\" == typeof c ? c(n, e) : c,\n            p = !0 === o || \"number\" == typeof o && n < o || \"function\" == typeof o && o(n, e);\n        !i && p ? (n++, null == t.onFail || t.onFail(n, e), Q(f).then(function () {\n          if (u()) return l();\n        }).then(function () {\n          i ? h(e) : d();\n        })) : h(e);\n      });\n    };\n\n    return A(t.networkMode) ? d() : l().then(d), {\n      promise: o,\n      cancel: function cancel(e) {\n        a || (h(new D(e)), null == t.abort || t.abort());\n      },\n      continue: function _continue() {\n        null == e || e();\n      },\n      cancelRetry: function cancelRetry() {\n        i = !0;\n      },\n      continueRetry: function continueRetry() {\n        i = !1;\n      }\n    };\n  }\n\n  var T = console;\n\n  var K = function () {\n    var t = [],\n        e = 0,\n        s = function s(t) {\n      t();\n    },\n        r = function r(t) {\n      t();\n    };\n\n    var i = function i(r) {\n      e ? t.push(r) : E(function () {\n        s(r);\n      });\n    },\n        n = function n() {\n      var e = t;\n      t = [], e.length && E(function () {\n        r(function () {\n          e.forEach(function (t) {\n            s(t);\n          });\n        });\n      });\n    };\n\n    return {\n      batch: function batch(t) {\n        var s;\n        e++;\n\n        try {\n          s = t();\n        } finally {\n          e--, e || n();\n        }\n\n        return s;\n      },\n      batchCalls: function batchCalls(t) {\n        return function () {\n          for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n            e[_key] = arguments[_key];\n          }\n\n          i(function () {\n            t.apply(void 0, e);\n          });\n        };\n      },\n      schedule: i,\n      setNotifyFunction: function setNotifyFunction(t) {\n        s = t;\n      },\n      setBatchNotifyFunction: function setBatchNotifyFunction(t) {\n        r = t;\n      }\n    };\n  }();\n\n  var k = /*#__PURE__*/function () {\n    function k() {\n      _classCallCheck(this, k);\n    }\n\n    _createClass(k, [{\n      key: \"destroy\",\n      value: function destroy() {\n        this.clearGcTimeout();\n      }\n    }, {\n      key: \"scheduleGc\",\n      value: function scheduleGc() {\n        var _this6 = this;\n\n        this.clearGcTimeout(), u(this.cacheTime) && (this.gcTimeout = setTimeout(function () {\n          _this6.optionalRemove();\n        }, this.cacheTime));\n      }\n    }, {\n      key: \"updateCacheTime\",\n      value: function updateCacheTime(t) {\n        this.cacheTime = Math.max(this.cacheTime || 0, null != t ? t : a ? 1 / 0 : 3e5);\n      }\n    }, {\n      key: \"clearGcTimeout\",\n      value: function clearGcTimeout() {\n        this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);\n      }\n    }]);\n\n    return k;\n  }();\n\n  var L = /*#__PURE__*/function (_k) {\n    _inherits(L, _k);\n\n    function L(t) {\n      var _this7;\n\n      _classCallCheck(this, L);\n\n      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(L).call(this)), _this7.abortSignalConsumed = !1, _this7.defaultOptions = t.defaultOptions, _this7.setOptions(t.options), _this7.observers = [], _this7.cache = t.cache, _this7.logger = t.logger || T, _this7.queryKey = t.queryKey, _this7.queryHash = t.queryHash, _this7.initialState = t.state || function (t) {\n        var e = \"function\" == typeof t.initialData ? t.initialData() : t.initialData,\n            s = void 0 !== t.initialData ? \"function\" == typeof t.initialDataUpdatedAt ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0,\n            r = void 0 !== e;\n        return {\n          data: e,\n          dataUpdateCount: 0,\n          dataUpdatedAt: r ? null != s ? s : Date.now() : 0,\n          error: null,\n          errorUpdateCount: 0,\n          errorUpdatedAt: 0,\n          fetchFailureCount: 0,\n          fetchMeta: null,\n          isInvalidated: !1,\n          status: r ? \"success\" : \"loading\",\n          fetchStatus: \"idle\"\n        };\n      }(_this7.options), _this7.state = _this7.initialState, _this7.meta = t.meta;\n      return _this7;\n    }\n\n    _createClass(L, [{\n      key: \"setOptions\",\n      value: function setOptions(t) {\n        this.options = _objectSpread({}, this.defaultOptions, t), this.meta = null == t ? void 0 : t.meta, this.updateCacheTime(this.options.cacheTime);\n      }\n    }, {\n      key: \"optionalRemove\",\n      value: function optionalRemove() {\n        this.observers.length || \"idle\" !== this.state.fetchStatus || this.cache.remove(this);\n      }\n    }, {\n      key: \"setData\",\n      value: function setData(t, e) {\n        var s = x(this.state.data, t, this.options);\n        return this.dispatch({\n          data: s,\n          type: \"success\",\n          dataUpdatedAt: null == e ? void 0 : e.updatedAt,\n          manual: null == e ? void 0 : e.manual\n        }), s;\n      }\n    }, {\n      key: \"setState\",\n      value: function setState(t, e) {\n        this.dispatch({\n          type: \"setState\",\n          state: t,\n          setStateOptions: e\n        });\n      }\n    }, {\n      key: \"cancel\",\n      value: function cancel(t) {\n        var e;\n        var s = this.promise;\n        return null == (e = this.retryer) || e.cancel(t), s ? s.then(o).catch(o) : Promise.resolve();\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        _get(_getPrototypeOf(L.prototype), \"destroy\", this).call(this), this.cancel({\n          silent: !0\n        });\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.destroy(), this.setState(this.initialState);\n      }\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return this.observers.some(function (t) {\n          return !1 !== t.options.enabled;\n        });\n      }\n    }, {\n      key: \"isDisabled\",\n      value: function isDisabled() {\n        return this.getObserversCount() > 0 && !this.isActive();\n      }\n    }, {\n      key: \"isStale\",\n      value: function isStale() {\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (t) {\n          return t.getCurrentResult().isStale;\n        });\n      }\n    }, {\n      key: \"isStaleByTime\",\n      value: function isStaleByTime() {\n        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || !h(this.state.dataUpdatedAt, t);\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        var t;\n        var e = this.observers.find(function (t) {\n          return t.shouldFetchOnWindowFocus();\n        });\n        e && e.refetch({\n          cancelRefetch: !1\n        }), null == (t = this.retryer) || t.continue();\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        var t;\n        var e = this.observers.find(function (t) {\n          return t.shouldFetchOnReconnect();\n        });\n        e && e.refetch({\n          cancelRefetch: !1\n        }), null == (t = this.retryer) || t.continue();\n      }\n    }, {\n      key: \"addObserver\",\n      value: function addObserver(t) {\n        -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({\n          type: \"observerAdded\",\n          query: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"removeObserver\",\n      value: function removeObserver(t) {\n        -1 !== this.observers.indexOf(t) && (this.observers = this.observers.filter(function (e) {\n          return e !== t;\n        }), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({\n          revert: !0\n        }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({\n          type: \"observerRemoved\",\n          query: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"getObserversCount\",\n      value: function getObserversCount() {\n        return this.observers.length;\n      }\n    }, {\n      key: \"invalidate\",\n      value: function invalidate() {\n        this.state.isInvalidated || this.dispatch({\n          type: \"invalidate\"\n        });\n      }\n    }, {\n      key: \"fetch\",\n      value: function fetch(t, e) {\n        var _this8 = this;\n\n        var s, r;\n        if (\"idle\" !== this.state.fetchStatus) if (this.state.dataUpdatedAt && null != e && e.cancelRefetch) this.cancel({\n          silent: !0\n        });else if (this.promise) {\n          var i;\n          return null == (i = this.retryer) || i.continueRetry(), this.promise;\n        }\n\n        if (t && this.setOptions(t), !this.options.queryFn) {\n          var _t2 = this.observers.find(function (t) {\n            return t.options.queryFn;\n          });\n\n          _t2 && this.setOptions(_t2.options);\n        }\n\n        Array.isArray(this.options.queryKey);\n\n        var n = function () {\n          if (\"function\" == typeof AbortController) return new AbortController();\n        }(),\n            a = {\n          queryKey: this.queryKey,\n          pageParam: void 0,\n          meta: this.meta\n        },\n            o = function o(t) {\n          Object.defineProperty(t, \"signal\", {\n            enumerable: !0,\n            get: function get() {\n              if (n) return _this8.abortSignalConsumed = !0, n.signal;\n            }\n          });\n        };\n\n        o(a);\n        var u = {\n          fetchOptions: e,\n          options: this.options,\n          queryKey: this.queryKey,\n          state: this.state,\n          fetchFn: function fetchFn() {\n            return _this8.options.queryFn ? (_this8.abortSignalConsumed = !1, _this8.options.queryFn(a)) : Promise.reject(\"Missing queryFn\");\n          },\n          meta: this.meta\n        };\n        var c;\n        (o(u), null == (s = this.options.behavior) || s.onFetch(u), this.revertState = this.state, \"idle\" === this.state.fetchStatus || this.state.fetchMeta !== (null == (r = u.fetchOptions) ? void 0 : r.meta)) && this.dispatch({\n          type: \"fetch\",\n          meta: null == (c = u.fetchOptions) ? void 0 : c.meta\n        });\n\n        var h = function h(t) {\n          var e, s;\n          (I(t) && t.silent || _this8.dispatch({\n            type: \"error\",\n            error: t\n          }), I(t)) || null == (e = (s = _this8.cache.config).onError) || e.call(s, t, _this8);\n          _this8.isFetchingOptimistic || _this8.scheduleGc(), _this8.isFetchingOptimistic = !1;\n        };\n\n        return this.retryer = U({\n          fn: u.fetchFn,\n          abort: null == n ? void 0 : n.abort.bind(n),\n          onSuccess: function onSuccess(t) {\n            var e, s;\n            void 0 !== t ? (_this8.setData(t), null == (e = (s = _this8.cache.config).onSuccess) || e.call(s, t, _this8), _this8.isFetchingOptimistic || _this8.scheduleGc(), _this8.isFetchingOptimistic = !1) : h(new Error(\"Query data cannot be undefined\"));\n          },\n          onError: h,\n          onFail: function onFail() {\n            _this8.dispatch({\n              type: \"failed\"\n            });\n          },\n          onPause: function onPause() {\n            _this8.dispatch({\n              type: \"pause\"\n            });\n          },\n          onContinue: function onContinue() {\n            _this8.dispatch({\n              type: \"continue\"\n            });\n          },\n          retry: u.options.retry,\n          retryDelay: u.options.retryDelay,\n          networkMode: u.options.networkMode\n        }), this.promise = this.retryer.promise, this.promise;\n      }\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(t) {\n        var _this9 = this;\n\n        this.state = function (e) {\n          var s, r;\n\n          switch (t.type) {\n            case \"failed\":\n              return _objectSpread({}, e, {\n                fetchFailureCount: e.fetchFailureCount + 1\n              });\n\n            case \"pause\":\n              return _objectSpread({}, e, {\n                fetchStatus: \"paused\"\n              });\n\n            case \"continue\":\n              return _objectSpread({}, e, {\n                fetchStatus: \"fetching\"\n              });\n\n            case \"fetch\":\n              return _objectSpread({}, e, {\n                fetchFailureCount: 0,\n                fetchMeta: null != (s = t.meta) ? s : null,\n                fetchStatus: A(_this9.options.networkMode) ? \"fetching\" : \"paused\"\n              }, !e.dataUpdatedAt && {\n                error: null,\n                status: \"loading\"\n              });\n\n            case \"success\":\n              return _objectSpread({}, e, {\n                data: t.data,\n                dataUpdateCount: e.dataUpdateCount + 1,\n                dataUpdatedAt: null != (r = t.dataUpdatedAt) ? r : Date.now(),\n                error: null,\n                isInvalidated: !1,\n                status: \"success\"\n              }, !t.manual && {\n                fetchStatus: \"idle\",\n                fetchFailureCount: 0\n              });\n\n            case \"error\":\n              var _i2 = t.error;\n              return I(_i2) && _i2.revert && _this9.revertState ? _objectSpread({}, _this9.revertState) : _objectSpread({}, e, {\n                error: _i2,\n                errorUpdateCount: e.errorUpdateCount + 1,\n                errorUpdatedAt: Date.now(),\n                fetchFailureCount: e.fetchFailureCount + 1,\n                fetchStatus: \"idle\",\n                status: \"error\"\n              });\n\n            case \"invalidate\":\n              return _objectSpread({}, e, {\n                isInvalidated: !0\n              });\n\n            case \"setState\":\n              return _objectSpread({}, e, t.state);\n          }\n        }(this.state), K.batch(function () {\n          _this9.observers.forEach(function (e) {\n            e.onQueryUpdate(t);\n          }), _this9.cache.notify({\n            query: _this9,\n            type: \"updated\",\n            action: t\n          });\n        });\n      }\n    }]);\n\n    return L;\n  }(k);\n\n  var j = /*#__PURE__*/function (_n5) {\n    _inherits(j, _n5);\n\n    function j(t) {\n      var _this10;\n\n      _classCallCheck(this, j);\n\n      _this10 = _possibleConstructorReturn(this, _getPrototypeOf(j).call(this)), _this10.config = t || {}, _this10.queries = [], _this10.queriesMap = {};\n      return _this10;\n    }\n\n    _createClass(j, [{\n      key: \"build\",\n      value: function build(t, e, s) {\n        var r;\n        var i = e.queryKey,\n            n = null != (r = e.queryHash) ? r : m(i, e);\n        var a = this.get(n);\n        return a || (a = new L({\n          cache: this,\n          logger: t.getLogger(),\n          queryKey: i,\n          queryHash: n,\n          options: t.defaultQueryOptions(e),\n          state: s,\n          defaultOptions: t.getQueryDefaults(i),\n          meta: e.meta\n        }), this.add(a)), a;\n      }\n    }, {\n      key: \"add\",\n      value: function add(t) {\n        this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({\n          type: \"added\",\n          query: t\n        }));\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(t) {\n        var e = this.queriesMap[t.queryHash];\n        e && (t.destroy(), this.queries = this.queries.filter(function (e) {\n          return e !== t;\n        }), e === t && delete this.queriesMap[t.queryHash], this.notify({\n          type: \"removed\",\n          query: t\n        }));\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this11 = this;\n\n        K.batch(function () {\n          _this11.queries.forEach(function (t) {\n            _this11.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function get(t) {\n        return this.queriesMap[t];\n      }\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        return this.queries;\n      }\n    }, {\n      key: \"find\",\n      value: function find(t, e) {\n        var _f = f(t, e),\n            _f2 = _slicedToArray(_f, 1),\n            s = _f2[0];\n\n        return void 0 === s.exact && (s.exact = !0), this.queries.find(function (t) {\n          return y(s, t);\n        });\n      }\n    }, {\n      key: \"findAll\",\n      value: function findAll(t, e) {\n        var _f3 = f(t, e),\n            _f4 = _slicedToArray(_f3, 1),\n            s = _f4[0];\n\n        return Object.keys(s).length > 0 ? this.queries.filter(function (t) {\n          return y(s, t);\n        }) : this.queries;\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this12 = this;\n\n        K.batch(function () {\n          _this12.listeners.forEach(function (e) {\n            e(t);\n          });\n        });\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        var _this13 = this;\n\n        K.batch(function () {\n          _this13.queries.forEach(function (t) {\n            t.onFocus();\n          });\n        });\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        var _this14 = this;\n\n        K.batch(function () {\n          _this14.queries.forEach(function (t) {\n            t.onOnline();\n          });\n        });\n      }\n    }]);\n\n    return j;\n  }(n);\n\n  var H = /*#__PURE__*/function (_k2) {\n    _inherits(H, _k2);\n\n    function H(t) {\n      var _this15;\n\n      _classCallCheck(this, H);\n\n      _this15 = _possibleConstructorReturn(this, _getPrototypeOf(H).call(this)), _this15.options = _objectSpread({}, t.defaultOptions, t.options), _this15.mutationId = t.mutationId, _this15.mutationCache = t.mutationCache, _this15.logger = t.logger || T, _this15.observers = [], _this15.state = t.state || N(), _this15.meta = t.meta, _this15.updateCacheTime(_this15.options.cacheTime), _this15.scheduleGc();\n      return _this15;\n    }\n\n    _createClass(H, [{\n      key: \"setState\",\n      value: function setState(t) {\n        this.dispatch({\n          type: \"setState\",\n          state: t\n        });\n      }\n    }, {\n      key: \"addObserver\",\n      value: function addObserver(t) {\n        -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({\n          type: \"observerAdded\",\n          mutation: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"removeObserver\",\n      value: function removeObserver(t) {\n        this.observers = this.observers.filter(function (e) {\n          return e !== t;\n        }), this.scheduleGc(), this.mutationCache.notify({\n          type: \"observerRemoved\",\n          mutation: this,\n          observer: t\n        });\n      }\n    }, {\n      key: \"optionalRemove\",\n      value: function optionalRemove() {\n        this.observers.length || (\"loading\" === this.state.status ? this.scheduleGc() : this.mutationCache.remove(this));\n      }\n    }, {\n      key: \"continue\",\n      value: function _continue() {\n        return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();\n      }\n    }, {\n      key: \"execute\",\n      value: function () {\n        var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _this16 = this;\n\n          var t, e, s, r, i, n, a, o, u, c, h, l, _t3, _d, d, f, p, y, v, m;\n\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  t = function t() {\n                    var t;\n                    return _this16.retryer = U({\n                      fn: function fn() {\n                        return _this16.options.mutationFn ? _this16.options.mutationFn(_this16.state.variables) : Promise.reject(\"No mutationFn found\");\n                      },\n                      onFail: function onFail() {\n                        _this16.dispatch({\n                          type: \"failed\"\n                        });\n                      },\n                      onPause: function onPause() {\n                        _this16.dispatch({\n                          type: \"pause\"\n                        });\n                      },\n                      onContinue: function onContinue() {\n                        _this16.dispatch({\n                          type: \"continue\"\n                        });\n                      },\n                      retry: null != (t = _this16.options.retry) ? t : 0,\n                      retryDelay: _this16.options.retryDelay,\n                      networkMode: _this16.options.networkMode\n                    }), _this16.retryer.promise;\n                  }, e = \"loading\" === this.state.status;\n                  _context.prev = 1;\n\n                  if (e) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  this.dispatch({\n                    type: \"loading\",\n                    variables: this.options.variables\n                  }), null == (u = (c = this.mutationCache.config).onMutate) || u.call(c, this.state.variables, this);\n                  _context.next = 6;\n                  return null == (h = (l = this.options).onMutate) ? void 0 : h.call(l, this.state.variables);\n\n                case 6:\n                  _t3 = _context.sent;\n                  _t3 !== this.state.context && this.dispatch({\n                    type: \"loading\",\n                    context: _t3,\n                    variables: this.state.variables\n                  });\n\n                case 8:\n                  _context.next = 10;\n                  return t();\n\n                case 10:\n                  _d = _context.sent;\n                  null == (s = (r = this.mutationCache.config).onSuccess) || s.call(r, _d, this.state.variables, this.state.context, this);\n                  _context.next = 14;\n                  return null == (i = (n = this.options).onSuccess) ? void 0 : i.call(n, _d, this.state.variables, this.state.context);\n\n                case 14:\n                  _context.next = 16;\n                  return null == (a = (o = this.options).onSettled) ? void 0 : a.call(o, _d, null, this.state.variables, this.state.context);\n\n                case 16:\n                  this.dispatch({\n                    type: \"success\",\n                    data: _d\n                  });\n                  return _context.abrupt(\"return\", _d);\n\n                case 20:\n                  _context.prev = 20;\n                  _context.t0 = _context[\"catch\"](1);\n                  _context.prev = 22;\n                  null == (d = (f = this.mutationCache.config).onError) || d.call(f, _context.t0, this.state.variables, this.state.context, this);\n                  _context.next = 26;\n                  return null == (p = (y = this.options).onError) ? void 0 : p.call(y, _context.t0, this.state.variables, this.state.context);\n\n                case 26:\n                  _context.next = 28;\n                  return null == (v = (m = this.options).onSettled) ? void 0 : v.call(m, void 0, _context.t0, this.state.variables, this.state.context);\n\n                case 28:\n                  throw _context.t0;\n\n                case 29:\n                  _context.prev = 29;\n                  this.dispatch({\n                    type: \"error\",\n                    error: _context.t0\n                  });\n                  return _context.finish(29);\n\n                case 32:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[1, 20], [22,, 29, 32]]);\n        }));\n\n        function execute() {\n          return _execute.apply(this, arguments);\n        }\n\n        return execute;\n      }()\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(t) {\n        var _this17 = this;\n\n        this.state = function (e) {\n          switch (t.type) {\n            case \"failed\":\n              return _objectSpread({}, e, {\n                failureCount: e.failureCount + 1\n              });\n\n            case \"pause\":\n              return _objectSpread({}, e, {\n                isPaused: !0\n              });\n\n            case \"continue\":\n              return _objectSpread({}, e, {\n                isPaused: !1\n              });\n\n            case \"loading\":\n              return _objectSpread({}, e, {\n                context: t.context,\n                data: void 0,\n                error: null,\n                isPaused: !A(_this17.options.networkMode),\n                status: \"loading\",\n                variables: t.variables\n              });\n\n            case \"success\":\n              return _objectSpread({}, e, {\n                data: t.data,\n                error: null,\n                status: \"success\",\n                isPaused: !1\n              });\n\n            case \"error\":\n              return _objectSpread({}, e, {\n                data: void 0,\n                error: t.error,\n                failureCount: e.failureCount + 1,\n                isPaused: !1,\n                status: \"error\"\n              });\n\n            case \"setState\":\n              return _objectSpread({}, e, t.state);\n          }\n        }(this.state), K.batch(function () {\n          _this17.observers.forEach(function (e) {\n            e.onMutationUpdate(t);\n          }), _this17.mutationCache.notify({\n            mutation: _this17,\n            type: \"updated\",\n            action: t\n          });\n        });\n      }\n    }]);\n\n    return H;\n  }(k);\n\n  function N() {\n    return {\n      context: void 0,\n      data: void 0,\n      error: null,\n      failureCount: 0,\n      isPaused: !1,\n      status: \"idle\",\n      variables: void 0\n    };\n  }\n\n  var B = /*#__PURE__*/function (_n6) {\n    _inherits(B, _n6);\n\n    function B(t) {\n      var _this18;\n\n      _classCallCheck(this, B);\n\n      _this18 = _possibleConstructorReturn(this, _getPrototypeOf(B).call(this)), _this18.config = t || {}, _this18.mutations = [], _this18.mutationId = 0;\n      return _this18;\n    }\n\n    _createClass(B, [{\n      key: \"build\",\n      value: function build(t, e, s) {\n        var r = new H({\n          mutationCache: this,\n          logger: t.getLogger(),\n          mutationId: ++this.mutationId,\n          options: t.defaultMutationOptions(e),\n          state: s,\n          defaultOptions: e.mutationKey ? t.getMutationDefaults(e.mutationKey) : void 0,\n          meta: e.meta\n        });\n        return this.add(r), r;\n      }\n    }, {\n      key: \"add\",\n      value: function add(t) {\n        this.mutations.push(t), this.notify({\n          type: \"added\",\n          mutation: t\n        });\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(t) {\n        this.mutations = this.mutations.filter(function (e) {\n          return e !== t;\n        }), this.notify({\n          type: \"removed\",\n          mutation: t\n        });\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this19 = this;\n\n        K.batch(function () {\n          _this19.mutations.forEach(function (t) {\n            _this19.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        return this.mutations;\n      }\n    }, {\n      key: \"find\",\n      value: function find(t) {\n        return void 0 === t.exact && (t.exact = !0), this.mutations.find(function (e) {\n          return v(t, e);\n        });\n      }\n    }, {\n      key: \"findAll\",\n      value: function findAll(t) {\n        return this.mutations.filter(function (e) {\n          return v(t, e);\n        });\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this20 = this;\n\n        K.batch(function () {\n          _this20.listeners.forEach(function (e) {\n            e(t);\n          });\n        });\n      }\n    }, {\n      key: \"resumePausedMutations\",\n      value: function resumePausedMutations() {\n        var t = this.mutations.filter(function (t) {\n          return t.state.isPaused;\n        });\n        return K.batch(function () {\n          return t.reduce(function (t, e) {\n            return t.then(function () {\n              return e.continue().catch(o);\n            });\n          }, Promise.resolve());\n        });\n      }\n    }]);\n\n    return B;\n  }(n);\n\n  function G() {\n    return {\n      onFetch: function onFetch(t) {\n        t.fetchFn = function () {\n          var e, s, r, i, n, a;\n          var o = null == (e = t.fetchOptions) || null == (s = e.meta) ? void 0 : s.refetchPage,\n              u = null == (r = t.fetchOptions) || null == (i = r.meta) ? void 0 : i.fetchMore,\n              c = null == u ? void 0 : u.pageParam,\n              h = \"forward\" === (null == u ? void 0 : u.direction),\n              l = \"backward\" === (null == u ? void 0 : u.direction),\n              d = (null == (n = t.state.data) ? void 0 : n.pages) || [],\n              f = (null == (a = t.state.data) ? void 0 : a.pageParams) || [];\n          var p = f,\n              y = !1;\n\n          var v = t.options.queryFn || function () {\n            return Promise.reject(\"Missing queryFn\");\n          },\n              m = function m(t, e, s, r) {\n            return p = r ? [e].concat(_toConsumableArray(p)) : [].concat(_toConsumableArray(p), [e]), r ? [s].concat(_toConsumableArray(t)) : [].concat(_toConsumableArray(t), [s]);\n          },\n              b = function b(e, s, r, i) {\n            if (y) return Promise.reject(\"Cancelled\");\n            if (void 0 === r && !s && e.length) return Promise.resolve(e);\n            var n = {\n              queryKey: t.queryKey,\n              pageParam: r,\n              meta: t.meta\n            };\n            var a;\n            a = n, Object.defineProperty(a, \"signal\", {\n              enumerable: !0,\n              get: function get() {\n                var e, s;\n                return null != (e = t.signal) && e.aborted ? y = !0 : null == (s = t.signal) || s.addEventListener(\"abort\", function () {\n                  y = !0;\n                }), t.signal;\n              }\n            });\n            var o = v(n);\n            return Promise.resolve(o).then(function (t) {\n              return m(e, r, t, i);\n            });\n          };\n\n          var g;\n          if (d.length) {\n            if (h) {\n              var _e3 = void 0 !== c,\n                  _s = _e3 ? c : _(t.options, d);\n\n              g = b(d, _e3, _s);\n            } else if (l) {\n              var _e4 = void 0 !== c,\n                  _s2 = _e4 ? c : W(t.options, d);\n\n              g = b(d, _e4, _s2, !0);\n            } else {\n              (function () {\n                p = [];\n                var e = void 0 === t.options.getNextPageParam;\n                g = !o || !d[0] || o(d[0], 0, d) ? b([], e, f[0]) : Promise.resolve(m([], f[0], d[0]));\n\n                var _loop = function _loop(_s3) {\n                  g = g.then(function (r) {\n                    if (!o || !d[_s3] || o(d[_s3], _s3, d)) {\n                      var _i3 = e ? f[_s3] : _(t.options, r);\n\n                      return b(r, e, _i3);\n                    }\n\n                    return Promise.resolve(m(r, f[_s3], d[_s3]));\n                  });\n                };\n\n                for (var _s3 = 1; _s3 < d.length; _s3++) {\n                  _loop(_s3);\n                }\n              })();\n            }\n          } else g = b([]);\n          return g.then(function (t) {\n            return {\n              pages: t,\n              pageParams: p\n            };\n          });\n        };\n      }\n    };\n  }\n\n  function _(t, e) {\n    return null == t.getNextPageParam ? void 0 : t.getNextPageParam(e[e.length - 1], e);\n  }\n\n  function W(t, e) {\n    return null == t.getPreviousPageParam ? void 0 : t.getPreviousPageParam(e[0], e);\n  }\n\n  function z(t, e) {\n    if (t.getNextPageParam && Array.isArray(e)) {\n      var s = _(t, e);\n\n      return null != s && !1 !== s;\n    }\n  }\n\n  function J(t, e) {\n    if (t.getPreviousPageParam && Array.isArray(e)) {\n      var s = W(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n\n  var V = /*#__PURE__*/function (_n7) {\n    _inherits(V, _n7);\n\n    function V(t, e) {\n      var _this21;\n\n      _classCallCheck(this, V);\n\n      _this21 = _possibleConstructorReturn(this, _getPrototypeOf(V).call(this)), _this21.client = t, _this21.options = e, _this21.trackedProps = new Set(), _this21.selectError = null, _this21.bindMethods(), _this21.setOptions(e);\n      return _this21;\n    }\n\n    _createClass(V, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);\n      }\n    }, {\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        1 === this.listeners.length && (this.currentQuery.addObserver(this), X(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        this.listeners.length || this.destroy();\n      }\n    }, {\n      key: \"shouldFetchOnReconnect\",\n      value: function shouldFetchOnReconnect() {\n        return Y(this.currentQuery, this.options, this.options.refetchOnReconnect);\n      }\n    }, {\n      key: \"shouldFetchOnWindowFocus\",\n      value: function shouldFetchOnWindowFocus() {\n        return Y(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.listeners = [], this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t, e) {\n        var s = this.options,\n            r = this.currentQuery;\n        if (this.options = this.client.defaultQueryOptions(t), void 0 !== this.options.enabled && \"boolean\" != typeof this.options.enabled) throw new Error(\"Expected enabled to be a boolean\");\n        this.options.queryKey || (this.options.queryKey = s.queryKey), this.updateQuery();\n        var i = this.hasListeners();\n        i && Z(this.currentQuery, r, this.options, s) && this.executeFetch(), this.updateResult(e), !i || this.currentQuery === r && this.options.enabled === s.enabled && this.options.staleTime === s.staleTime || this.updateStaleTimeout();\n        var n = this.computeRefetchInterval();\n        !i || this.currentQuery === r && this.options.enabled === s.enabled && n === this.currentRefetchInterval || this.updateRefetchInterval(n);\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        var e = this.client.getQueryCache().build(this.client, t);\n        return this.createResult(e, t);\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.currentResult;\n      }\n    }, {\n      key: \"trackResult\",\n      value: function trackResult(t) {\n        var _this22 = this;\n\n        var e = {};\n        return Object.keys(t).forEach(function (s) {\n          Object.defineProperty(e, s, {\n            configurable: !1,\n            enumerable: !0,\n            get: function get() {\n              return _this22.trackedProps.add(s), t[s];\n            }\n          });\n        }), e;\n      }\n    }, {\n      key: \"getCurrentQuery\",\n      value: function getCurrentQuery() {\n        return this.currentQuery;\n      }\n    }, {\n      key: \"remove\",\n      value: function remove() {\n        this.client.getQueryCache().remove(this.currentQuery);\n      }\n    }, {\n      key: \"refetch\",\n      value: function refetch() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref.refetchPage,\n            e = _objectWithoutProperties(_ref, [\"refetchPage\"]);\n\n        return this.fetch(_objectSpread({}, e, {\n          meta: {\n            refetchPage: t\n          }\n        }));\n      }\n    }, {\n      key: \"fetchOptimistic\",\n      value: function fetchOptimistic(t) {\n        var _this23 = this;\n\n        var e = this.client.defaultQueryOptions(t),\n            s = this.client.getQueryCache().build(this.client, e);\n        return s.isFetchingOptimistic = !0, s.fetch().then(function () {\n          return _this23.createResult(s, e);\n        });\n      }\n    }, {\n      key: \"fetch\",\n      value: function fetch(t) {\n        var _this24 = this;\n\n        var e;\n        return this.executeFetch(_objectSpread({}, t, {\n          cancelRefetch: null == (e = t.cancelRefetch) || e\n        })).then(function () {\n          return _this24.updateResult(), _this24.currentResult;\n        });\n      }\n    }, {\n      key: \"executeFetch\",\n      value: function executeFetch(t) {\n        this.updateQuery();\n        var e = this.currentQuery.fetch(this.options, t);\n        return null != t && t.throwOnError || (e = e.catch(o)), e;\n      }\n    }, {\n      key: \"updateStaleTimeout\",\n      value: function updateStaleTimeout() {\n        var _this25 = this;\n\n        if (this.clearStaleTimeout(), a || this.currentResult.isStale || !u(this.options.staleTime)) return;\n        var t = h(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;\n        this.staleTimeoutId = setTimeout(function () {\n          _this25.currentResult.isStale || _this25.updateResult();\n        }, t);\n      }\n    }, {\n      key: \"computeRefetchInterval\",\n      value: function computeRefetchInterval() {\n        var t;\n        return \"function\" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (t = this.options.refetchInterval) && t;\n      }\n    }, {\n      key: \"updateRefetchInterval\",\n      value: function updateRefetchInterval(t) {\n        var _this26 = this;\n\n        this.clearRefetchInterval(), this.currentRefetchInterval = t, !a && !1 !== this.options.enabled && u(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval(function () {\n          (_this26.options.refetchIntervalInBackground || M.isFocused()) && _this26.executeFetch();\n        }, this.currentRefetchInterval));\n      }\n    }, {\n      key: \"updateTimers\",\n      value: function updateTimers() {\n        this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());\n      }\n    }, {\n      key: \"clearStaleTimeout\",\n      value: function clearStaleTimeout() {\n        this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);\n      }\n    }, {\n      key: \"clearRefetchInterval\",\n      value: function clearRefetchInterval() {\n        this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);\n      }\n    }, {\n      key: \"createResult\",\n      value: function createResult(t, e) {\n        var s = this.currentQuery,\n            r = this.options,\n            i = this.currentResult,\n            n = this.currentResultState,\n            a = this.currentResultOptions,\n            o = t !== s,\n            u = o ? t.state : this.currentQueryInitialState,\n            c = o ? this.currentResult : this.previousQueryResult,\n            h = t.state;\n        var l,\n            d = h.dataUpdatedAt,\n            f = h.error,\n            p = h.errorUpdatedAt,\n            y = h.fetchStatus,\n            v = h.status,\n            m = !1,\n            b = !1;\n\n        if (e._optimisticResults) {\n          var _i4 = this.hasListeners(),\n              _n8 = !_i4 && X(t, e),\n              _a2 = _i4 && Z(t, s, e, r);\n\n          (_n8 || _a2) && (y = A(t.options.networkMode) ? \"fetching\" : \"paused\", d || (v = \"loading\")), \"isRestoring\" === e._optimisticResults && (y = \"idle\");\n        }\n\n        if (e.keepPreviousData && !h.dataUpdateCount && null != c && c.isSuccess && \"error\" !== v) l = c.data, d = c.dataUpdatedAt, v = c.status, m = !0;else if (e.select && void 0 !== h.data) {\n          if (i && h.data === (null == n ? void 0 : n.data) && e.select === this.selectFn) l = this.selectResult;else try {\n            this.selectFn = e.select, l = e.select(h.data), l = x(null == i ? void 0 : i.data, l, e), this.selectResult = l, this.selectError = null;\n          } catch (t) {\n            this.selectError = t;\n          }\n        } else l = h.data;\n\n        if (void 0 !== e.placeholderData && void 0 === l && \"loading\" === v) {\n          var _t4;\n\n          if (null != i && i.isPlaceholderData && e.placeholderData === (null == a ? void 0 : a.placeholderData)) _t4 = i.data;else if (_t4 = \"function\" == typeof e.placeholderData ? e.placeholderData() : e.placeholderData, e.select && void 0 !== _t4) try {\n            _t4 = e.select(_t4), _t4 = x(null == i ? void 0 : i.data, _t4, e), this.selectError = null;\n          } catch (t) {\n            this.selectError = t;\n          }\n          void 0 !== _t4 && (v = \"success\", l = _t4, b = !0);\n        }\n\n        this.selectError && (f = this.selectError, l = this.selectResult, p = Date.now(), v = \"error\");\n        var g = \"fetching\" === y;\n        return {\n          status: v,\n          fetchStatus: y,\n          isLoading: \"loading\" === v,\n          isSuccess: \"success\" === v,\n          isError: \"error\" === v,\n          data: l,\n          dataUpdatedAt: d,\n          error: f,\n          errorUpdatedAt: p,\n          failureCount: h.fetchFailureCount,\n          errorUpdateCount: h.errorUpdateCount,\n          isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,\n          isFetchedAfterMount: h.dataUpdateCount > u.dataUpdateCount || h.errorUpdateCount > u.errorUpdateCount,\n          isFetching: g,\n          isRefetching: g && \"loading\" !== v,\n          isLoadingError: \"error\" === v && 0 === h.dataUpdatedAt,\n          isPaused: \"paused\" === y,\n          isPlaceholderData: b,\n          isPreviousData: m,\n          isRefetchError: \"error\" === v && 0 !== h.dataUpdatedAt,\n          isStale: $(t, e),\n          refetch: this.refetch,\n          remove: this.remove\n        };\n      }\n    }, {\n      key: \"updateResult\",\n      value: function updateResult(t) {\n        var _this27 = this;\n\n        var e = this.currentResult,\n            s = this.createResult(this.currentQuery, this.options);\n        if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, function (t, e) {\n          if (t && !e || e && !t) return !1;\n\n          for (var _s4 in t) {\n            if (t[_s4] !== e[_s4]) return !1;\n          }\n\n          return !0;\n        }(s, e)) return;\n        this.currentResult = s;\n        var r = {\n          cache: !0\n        };\n        !1 !== (null == t ? void 0 : t.listeners) && function () {\n          if (!e) return !0;\n          var t = _this27.options.notifyOnChangeProps;\n          if (\"all\" === t || !t && !_this27.trackedProps.size) return !0;\n          var s = new Set(null != t ? t : _this27.trackedProps);\n          return _this27.options.useErrorBoundary && s.add(\"error\"), Object.keys(_this27.currentResult).some(function (t) {\n            var r = t;\n            return _this27.currentResult[r] !== e[r] && s.has(r);\n          });\n        }() && (r.listeners = !0), this.notify(_objectSpread({}, r, t));\n      }\n    }, {\n      key: \"updateQuery\",\n      value: function updateQuery() {\n        var t = this.client.getQueryCache().build(this.client, this.options);\n        if (t === this.currentQuery) return;\n        var e = this.currentQuery;\n        this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == e || e.removeObserver(this), t.addObserver(this));\n      }\n    }, {\n      key: \"onQueryUpdate\",\n      value: function onQueryUpdate(t) {\n        var e = {};\n        \"success\" === t.type ? e.onSuccess = !t.manual : \"error\" !== t.type || I(t.error) || (e.onError = !0), this.updateResult(e), this.hasListeners() && this.updateTimers();\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this28 = this;\n\n        K.batch(function () {\n          var e, s, r, i;\n          if (t.onSuccess) null == (e = (s = _this28.options).onSuccess) || e.call(s, _this28.currentResult.data), null == (r = (i = _this28.options).onSettled) || r.call(i, _this28.currentResult.data, null);else if (t.onError) {\n            var n, a, o, u;\n            null == (n = (a = _this28.options).onError) || n.call(a, _this28.currentResult.error), null == (o = (u = _this28.options).onSettled) || o.call(u, void 0, _this28.currentResult.error);\n          }\n          t.listeners && _this28.listeners.forEach(function (t) {\n            t(_this28.currentResult);\n          }), t.cache && _this28.client.getQueryCache().notify({\n            query: _this28.currentQuery,\n            type: \"observerResultsUpdated\"\n          });\n        });\n      }\n    }]);\n\n    return V;\n  }(n);\n\n  function X(t, e) {\n    return function (t, e) {\n      return !(!1 === e.enabled || t.state.dataUpdatedAt || \"error\" === t.state.status && !1 === e.retryOnMount);\n    }(t, e) || t.state.dataUpdatedAt > 0 && Y(t, e, e.refetchOnMount);\n  }\n\n  function Y(t, e, s) {\n    if (!1 !== e.enabled) {\n      var r = \"function\" == typeof s ? s(t) : s;\n      return \"always\" === r || !1 !== r && $(t, e);\n    }\n\n    return !1;\n  }\n\n  function Z(t, e, s, r) {\n    return !1 !== s.enabled && (t !== e || !1 === r.enabled) && (!s.suspense || \"error\" !== t.state.status) && $(t, s);\n  }\n\n  function $(t, e) {\n    return t.isStaleByTime(e.staleTime);\n  }\n\n  var tt = /*#__PURE__*/function (_n9) {\n    _inherits(tt, _n9);\n\n    function tt(t, e) {\n      var _this29;\n\n      _classCallCheck(this, tt);\n\n      _this29 = _possibleConstructorReturn(this, _getPrototypeOf(tt).call(this)), _this29.client = t, _this29.queries = [], _this29.result = [], _this29.observers = [], _this29.observersMap = {}, e && _this29.setQueries(e);\n      return _this29;\n    }\n\n    _createClass(tt, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        var _this30 = this;\n\n        1 === this.listeners.length && this.observers.forEach(function (t) {\n          t.subscribe(function (e) {\n            _this30.onUpdate(t, e);\n          });\n        });\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        this.listeners.length || this.destroy();\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.listeners = [], this.observers.forEach(function (t) {\n          t.destroy();\n        });\n      }\n    }, {\n      key: \"setQueries\",\n      value: function setQueries(t, e) {\n        var _this31 = this;\n\n        this.queries = t, K.batch(function () {\n          var t = _this31.observers,\n              s = _this31.findMatchingObservers(_this31.queries);\n\n          s.forEach(function (t) {\n            return t.observer.setOptions(t.defaultedQueryOptions, e);\n          });\n          var r = s.map(function (t) {\n            return t.observer;\n          }),\n              i = Object.fromEntries(r.map(function (t) {\n            return [t.options.queryHash, t];\n          })),\n              n = r.map(function (t) {\n            return t.getCurrentResult();\n          }),\n              a = r.some(function (e, s) {\n            return e !== t[s];\n          });\n          (t.length !== r.length || a) && (_this31.observers = r, _this31.observersMap = i, _this31.result = n, _this31.hasListeners() && (c(t, r).forEach(function (t) {\n            t.destroy();\n          }), c(r, t).forEach(function (t) {\n            t.subscribe(function (e) {\n              _this31.onUpdate(t, e);\n            });\n          }), _this31.notify()));\n        });\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.result;\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        return this.findMatchingObservers(t).map(function (t) {\n          return t.observer.getOptimisticResult(t.defaultedQueryOptions);\n        });\n      }\n    }, {\n      key: \"findMatchingObservers\",\n      value: function findMatchingObservers(t) {\n        var _this32 = this;\n\n        var e = this.observers,\n            s = t.map(function (t) {\n          return _this32.client.defaultQueryOptions(t);\n        }),\n            r = s.flatMap(function (t) {\n          var s = e.find(function (e) {\n            return e.options.queryHash === t.queryHash;\n          });\n          return null != s ? [{\n            defaultedQueryOptions: t,\n            observer: s\n          }] : [];\n        }),\n            i = r.map(function (t) {\n          return t.defaultedQueryOptions.queryHash;\n        }),\n            n = s.filter(function (t) {\n          return !i.includes(t.queryHash);\n        }),\n            a = e.filter(function (t) {\n          return !r.some(function (e) {\n            return e.observer === t;\n          });\n        }),\n            o = function o(t) {\n          var e = _this32.client.defaultQueryOptions(t),\n              s = _this32.observersMap[e.queryHash];\n\n          return null != s ? s : new V(_this32.client, e);\n        },\n            u = n.map(function (t, e) {\n          if (t.keepPreviousData) {\n            var _s5 = a[e];\n            if (void 0 !== _s5) return {\n              defaultedQueryOptions: t,\n              observer: _s5\n            };\n          }\n\n          return {\n            defaultedQueryOptions: t,\n            observer: o(t)\n          };\n        });\n\n        return r.concat(u).sort(function (t, e) {\n          return s.indexOf(t.defaultedQueryOptions) - s.indexOf(e.defaultedQueryOptions);\n        });\n      }\n    }, {\n      key: \"onUpdate\",\n      value: function onUpdate(t, e) {\n        var s = this.observers.indexOf(t);\n        -1 !== s && (this.result = function (t, e, s) {\n          var r = t.slice(0);\n          return r[e] = s, r;\n        }(this.result, s, e), this.notify());\n      }\n    }, {\n      key: \"notify\",\n      value: function notify() {\n        var _this33 = this;\n\n        K.batch(function () {\n          _this33.listeners.forEach(function (t) {\n            t(_this33.result);\n          });\n        });\n      }\n    }]);\n\n    return tt;\n  }(n);\n\n  var et = /*#__PURE__*/function (_V) {\n    _inherits(et, _V);\n\n    function et(t, e) {\n      _classCallCheck(this, et);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(et).call(this, t, e));\n    }\n\n    _createClass(et, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        _get(_getPrototypeOf(et.prototype), \"bindMethods\", this).call(this), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t, e) {\n        _get(_getPrototypeOf(et.prototype), \"setOptions\", this).call(this, _objectSpread({}, t, {\n          behavior: G()\n        }), e);\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        return t.behavior = G(), _get(_getPrototypeOf(et.prototype), \"getOptimisticResult\", this).call(this, t);\n      }\n    }, {\n      key: \"fetchNextPage\",\n      value: function fetchNextPage() {\n        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref2.pageParam,\n            e = _objectWithoutProperties(_ref2, [\"pageParam\"]);\n\n        return this.fetch(_objectSpread({}, e, {\n          meta: {\n            fetchMore: {\n              direction: \"forward\",\n              pageParam: t\n            }\n          }\n        }));\n      }\n    }, {\n      key: \"fetchPreviousPage\",\n      value: function fetchPreviousPage() {\n        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref3.pageParam,\n            e = _objectWithoutProperties(_ref3, [\"pageParam\"]);\n\n        return this.fetch(_objectSpread({}, e, {\n          meta: {\n            fetchMore: {\n              direction: \"backward\",\n              pageParam: t\n            }\n          }\n        }));\n      }\n    }, {\n      key: \"createResult\",\n      value: function createResult(t, e) {\n        var s, r, i, n, a, o;\n        var u = t.state;\n        return _objectSpread({}, _get(_getPrototypeOf(et.prototype), \"createResult\", this).call(this, t, e), {\n          fetchNextPage: this.fetchNextPage,\n          fetchPreviousPage: this.fetchPreviousPage,\n          hasNextPage: z(e, null == (s = u.data) ? void 0 : s.pages),\n          hasPreviousPage: J(e, null == (r = u.data) ? void 0 : r.pages),\n          isFetchingNextPage: \"fetching\" === u.fetchStatus && \"forward\" === (null == (i = u.fetchMeta) || null == (n = i.fetchMore) ? void 0 : n.direction),\n          isFetchingPreviousPage: \"fetching\" === u.fetchStatus && \"backward\" === (null == (a = u.fetchMeta) || null == (o = a.fetchMore) ? void 0 : o.direction)\n        });\n      }\n    }]);\n\n    return et;\n  }(V);\n\n  var st = /*#__PURE__*/function (_n10) {\n    _inherits(st, _n10);\n\n    function st(t, e) {\n      var _this34;\n\n      _classCallCheck(this, st);\n\n      _this34 = _possibleConstructorReturn(this, _getPrototypeOf(st).call(this)), _this34.client = t, _this34.setOptions(e), _this34.bindMethods(), _this34.updateResult();\n      return _this34;\n    }\n\n    _createClass(st, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t) {\n        this.options = this.client.defaultMutationOptions(t);\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.listeners.length || null == (t = this.currentMutation) || t.removeObserver(this);\n      }\n    }, {\n      key: \"onMutationUpdate\",\n      value: function onMutationUpdate(t) {\n        this.updateResult();\n        var e = {\n          listeners: !0\n        };\n        \"success\" === t.type ? e.onSuccess = !0 : \"error\" === t.type && (e.onError = !0), this.notify(e);\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.currentResult;\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.currentMutation = void 0, this.updateResult(), this.notify({\n          listeners: !0\n        });\n      }\n    }, {\n      key: \"mutate\",\n      value: function mutate(t, e) {\n        return this.mutateOptions = e, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, _objectSpread({}, this.options, {\n          variables: void 0 !== t ? t : this.options.variables\n        })), this.currentMutation.addObserver(this), this.currentMutation.execute();\n      }\n    }, {\n      key: \"updateResult\",\n      value: function updateResult() {\n        var t = this.currentMutation ? this.currentMutation.state : {\n          context: void 0,\n          data: void 0,\n          error: null,\n          failureCount: 0,\n          isPaused: !1,\n          status: \"idle\",\n          variables: void 0\n        },\n            e = _objectSpread({}, t, {\n          isLoading: \"loading\" === t.status,\n          isSuccess: \"success\" === t.status,\n          isError: \"error\" === t.status,\n          isIdle: \"idle\" === t.status,\n          mutate: this.mutate,\n          reset: this.reset\n        });\n\n        this.currentResult = e;\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this35 = this;\n\n        K.batch(function () {\n          var e, s, r, i;\n          if (_this35.mutateOptions) if (t.onSuccess) null == (e = (s = _this35.mutateOptions).onSuccess) || e.call(s, _this35.currentResult.data, _this35.currentResult.variables, _this35.currentResult.context), null == (r = (i = _this35.mutateOptions).onSettled) || r.call(i, _this35.currentResult.data, null, _this35.currentResult.variables, _this35.currentResult.context);else if (t.onError) {\n            var n, a, o, u;\n            null == (n = (a = _this35.mutateOptions).onError) || n.call(a, _this35.currentResult.error, _this35.currentResult.variables, _this35.currentResult.context), null == (o = (u = _this35.mutateOptions).onSettled) || o.call(u, void 0, _this35.currentResult.error, _this35.currentResult.variables, _this35.currentResult.context);\n          }\n          t.listeners && _this35.listeners.forEach(function (t) {\n            t(_this35.currentResult);\n          });\n        });\n      }\n    }]);\n\n    return st;\n  }(n);\n\n  function rt(t) {\n    return t.state.isPaused;\n  }\n\n  function it(t) {\n    return \"success\" === t.state.status;\n  }\n\n  function nt(t, e, s) {\n    if (\"object\" != typeof e || null === e) return;\n    var r = t.getMutationCache(),\n        i = t.getQueryCache(),\n        n = e.mutations || [],\n        a = e.queries || [];\n    n.forEach(function (e) {\n      var i;\n      r.build(t, _objectSpread({}, null == s || null == (i = s.defaultOptions) ? void 0 : i.mutations, {\n        mutationKey: e.mutationKey\n      }), e.state);\n    }), a.forEach(function (e) {\n      var r;\n      var n = i.get(e.queryHash);\n      n ? n.state.dataUpdatedAt < e.state.dataUpdatedAt && n.setState(e.state) : i.build(t, _objectSpread({}, null == s || null == (r = s.defaultOptions) ? void 0 : r.queries, {\n        queryKey: e.queryKey,\n        queryHash: e.queryHash\n      }), e.state);\n    });\n  }\n\n  var at = i.createContext(void 0),\n      ot = i.createContext(!1);\n\n  function ut(t, e) {\n    return t || (e && \"undefined\" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = at), window.ReactQueryClientContext) : at);\n  }\n\n  var ct = function ct() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        t = _ref4.context;\n\n    var e = i.useContext(ut(t, i.useContext(ot)));\n    if (!e) throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    return e;\n  },\n      ht = i.createContext(!1),\n      lt = function lt() {\n    return i.useContext(ht);\n  },\n      dt = ht.Provider;\n\n  function ft() {\n    var t = !1;\n    return {\n      clearReset: function clearReset() {\n        t = !1;\n      },\n      reset: function reset() {\n        t = !0;\n      },\n      isReset: function isReset() {\n        return t;\n      }\n    };\n  }\n\n  var pt = i.createContext(ft()),\n      yt = function yt() {\n    return i.useContext(pt);\n  };\n\n  function vt(t, e) {\n    return \"function\" == typeof t ? t.apply(void 0, _toConsumableArray(e)) : !!t;\n  }\n\n  function mt(t, e) {\n    var r = ct({\n      context: t.context\n    }),\n        n = lt(),\n        a = yt(),\n        o = r.defaultQueryOptions(t);\n    o._optimisticResults = n ? \"isRestoring\" : \"optimistic\", o.onError && (o.onError = K.batchCalls(o.onError)), o.onSuccess && (o.onSuccess = K.batchCalls(o.onSuccess)), o.onSettled && (o.onSettled = K.batchCalls(o.onSettled)), o.suspense && \"number\" != typeof o.staleTime && (o.staleTime = 1e3), (o.suspense || o.useErrorBoundary) && (a.isReset() || (o.retryOnMount = !1));\n\n    var _i$useState = i.useState(function () {\n      return new e(r, o);\n    }),\n        _i$useState2 = _slicedToArray(_i$useState, 1),\n        u = _i$useState2[0],\n        c = u.getOptimisticResult(o);\n\n    if (s.useSyncExternalStore(i.useCallback(function (t) {\n      return n ? function () {} : u.subscribe(K.batchCalls(t));\n    }, [u, n]), function () {\n      return u.getCurrentResult();\n    }, function () {\n      return u.getCurrentResult();\n    }), i.useEffect(function () {\n      a.clearReset();\n    }, [a]), i.useEffect(function () {\n      u.setOptions(o, {\n        listeners: !1\n      });\n    }, [o, u]), o.suspense && c.isLoading && c.isFetching && !n) throw u.fetchOptimistic(o).then(function (_ref5) {\n      var t = _ref5.data;\n      null == o.onSuccess || o.onSuccess(t), null == o.onSettled || o.onSettled(t, null);\n    }).catch(function (t) {\n      a.clearReset(), null == o.onError || o.onError(t), null == o.onSettled || o.onSettled(void 0, t);\n    });\n    if (c.isError && !a.isReset() && !c.isFetching && vt(o.useErrorBoundary, [c.error, u.getCurrentQuery()])) throw c.error;\n    return o.notifyOnChangeProps ? c : u.trackResult(c);\n  }\n\n  function bt(t) {\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var s = ct({\n      context: e.context\n    }),\n        r = i.useRef(e);\n    r.current = e, i.useMemo(function () {\n      t && nt(s, t, r.current);\n    }, [s, t]);\n  }\n\n  function gt() {}\n\n  t.CancelledError = D, t.Hydrate = function (_ref6) {\n    var t = _ref6.children,\n        e = _ref6.options,\n        s = _ref6.state;\n    return bt(s, e), t;\n  }, t.InfiniteQueryObserver = et, t.IsRestoringProvider = dt, t.MutationCache = B, t.MutationObserver = st, t.QueriesObserver = tt, t.QueryCache = j, t.QueryClient = /*#__PURE__*/function () {\n    function _class3() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, _class3);\n\n      this.queryCache = t.queryCache || new j(), this.mutationCache = t.mutationCache || new B(), this.logger = t.logger || T, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];\n    }\n\n    _createClass(_class3, [{\n      key: \"mount\",\n      value: function mount() {\n        var _this36 = this;\n\n        this.unsubscribeFocus = M.subscribe(function () {\n          M.isFocused() && (_this36.resumePausedMutations(), _this36.queryCache.onFocus());\n        }), this.unsubscribeOnline = w.subscribe(function () {\n          w.isOnline() && (_this36.resumePausedMutations(), _this36.queryCache.onOnline());\n        });\n      }\n    }, {\n      key: \"unmount\",\n      value: function unmount() {\n        var t, e;\n        null == (t = this.unsubscribeFocus) || t.call(this), null == (e = this.unsubscribeOnline) || e.call(this);\n      }\n    }, {\n      key: \"isFetching\",\n      value: function isFetching(t, e) {\n        var _f5 = f(t, e),\n            _f6 = _slicedToArray(_f5, 1),\n            s = _f6[0];\n\n        return s.fetchStatus = \"fetching\", this.queryCache.findAll(s).length;\n      }\n    }, {\n      key: \"isMutating\",\n      value: function isMutating(t) {\n        return this.mutationCache.findAll(_objectSpread({}, t, {\n          fetching: !0\n        })).length;\n      }\n    }, {\n      key: \"getQueryData\",\n      value: function getQueryData(t, e) {\n        var s;\n        return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state.data;\n      }\n    }, {\n      key: \"getQueriesData\",\n      value: function getQueriesData(t) {\n        return this.getQueryCache().findAll(t).map(function (_ref7) {\n          var t = _ref7.queryKey,\n              e = _ref7.state;\n          return [t, e.data];\n        });\n      }\n    }, {\n      key: \"setQueryData\",\n      value: function setQueryData(t, e, s) {\n        var r = this.queryCache.find(t),\n            i = function (t, e) {\n          return \"function\" == typeof t ? t(e) : t;\n        }(e, null == r ? void 0 : r.state.data);\n\n        if (void 0 === i) return;\n        var n = l(t),\n            a = this.defaultQueryOptions(n);\n        return this.queryCache.build(this, a).setData(i, _objectSpread({}, s, {\n          manual: !0\n        }));\n      }\n    }, {\n      key: \"setQueriesData\",\n      value: function setQueriesData(t, e, s) {\n        var _this37 = this;\n\n        return K.batch(function () {\n          return _this37.getQueryCache().findAll(t).map(function (_ref8) {\n            var t = _ref8.queryKey;\n            return [t, _this37.setQueryData(t, e, s)];\n          });\n        });\n      }\n    }, {\n      key: \"getQueryState\",\n      value: function getQueryState(t, e) {\n        var s;\n        return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state;\n      }\n    }, {\n      key: \"removeQueries\",\n      value: function removeQueries(t, e) {\n        var _f7 = f(t, e),\n            _f8 = _slicedToArray(_f7, 1),\n            s = _f8[0],\n            r = this.queryCache;\n\n        K.batch(function () {\n          r.findAll(s).forEach(function (t) {\n            r.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"resetQueries\",\n      value: function resetQueries(t, e, s) {\n        var _this38 = this;\n\n        var _f9 = f(t, e, s),\n            _f10 = _slicedToArray(_f9, 2),\n            r = _f10[0],\n            i = _f10[1],\n            n = this.queryCache,\n            a = _objectSpread({\n          type: \"active\"\n        }, r);\n\n        return K.batch(function () {\n          return n.findAll(r).forEach(function (t) {\n            t.reset();\n          }), _this38.refetchQueries(a, i);\n        });\n      }\n    }, {\n      key: \"cancelQueries\",\n      value: function cancelQueries(t, e, s) {\n        var _this39 = this;\n\n        var _f11 = f(t, e, s),\n            _f12 = _slicedToArray(_f11, 2),\n            r = _f12[0],\n            _f12$ = _f12[1],\n            i = _f12$ === void 0 ? {} : _f12$;\n\n        void 0 === i.revert && (i.revert = !0);\n        var n = K.batch(function () {\n          return _this39.queryCache.findAll(r).map(function (t) {\n            return t.cancel(i);\n          });\n        });\n        return Promise.all(n).then(o).catch(o);\n      }\n    }, {\n      key: \"invalidateQueries\",\n      value: function invalidateQueries(t, e, s) {\n        var _this40 = this;\n\n        var _f13 = f(t, e, s),\n            _f14 = _slicedToArray(_f13, 2),\n            r = _f14[0],\n            i = _f14[1];\n\n        return K.batch(function () {\n          var t, e;\n          if (_this40.queryCache.findAll(r).forEach(function (t) {\n            t.invalidate();\n          }), \"none\" === r.refetchType) return Promise.resolve();\n\n          var s = _objectSpread({}, r, {\n            type: null != (t = null != (e = r.refetchType) ? e : r.type) ? t : \"active\"\n          });\n\n          return _this40.refetchQueries(s, i);\n        });\n      }\n    }, {\n      key: \"refetchQueries\",\n      value: function refetchQueries(t, e, s) {\n        var _this41 = this;\n\n        var _f15 = f(t, e, s),\n            _f16 = _slicedToArray(_f15, 2),\n            r = _f16[0],\n            i = _f16[1],\n            n = K.batch(function () {\n          return _this41.queryCache.findAll(r).filter(function (t) {\n            return !t.isDisabled();\n          }).map(function (t) {\n            var e;\n            return t.fetch(void 0, _objectSpread({}, i, {\n              cancelRefetch: null == (e = null == i ? void 0 : i.cancelRefetch) || e,\n              meta: {\n                refetchPage: r.refetchPage\n              }\n            }));\n          });\n        });\n\n        var a = Promise.all(n).then(o);\n        return null != i && i.throwOnError || (a = a.catch(o)), a;\n      }\n    }, {\n      key: \"fetchQuery\",\n      value: function fetchQuery(t, e, s) {\n        var r = l(t, e, s),\n            i = this.defaultQueryOptions(r);\n        void 0 === i.retry && (i.retry = !1);\n        var n = this.queryCache.build(this, i);\n        return n.isStaleByTime(i.staleTime) ? n.fetch(i) : Promise.resolve(n.state.data);\n      }\n    }, {\n      key: \"prefetchQuery\",\n      value: function prefetchQuery(t, e, s) {\n        return this.fetchQuery(t, e, s).then(o).catch(o);\n      }\n    }, {\n      key: \"fetchInfiniteQuery\",\n      value: function fetchInfiniteQuery(t, e, s) {\n        var r = l(t, e, s);\n        return r.behavior = G(), this.fetchQuery(r);\n      }\n    }, {\n      key: \"prefetchInfiniteQuery\",\n      value: function prefetchInfiniteQuery(t, e, s) {\n        return this.fetchInfiniteQuery(t, e, s).then(o).catch(o);\n      }\n    }, {\n      key: \"resumePausedMutations\",\n      value: function resumePausedMutations() {\n        return this.mutationCache.resumePausedMutations();\n      }\n    }, {\n      key: \"getQueryCache\",\n      value: function getQueryCache() {\n        return this.queryCache;\n      }\n    }, {\n      key: \"getMutationCache\",\n      value: function getMutationCache() {\n        return this.mutationCache;\n      }\n    }, {\n      key: \"getLogger\",\n      value: function getLogger() {\n        return this.logger;\n      }\n    }, {\n      key: \"getDefaultOptions\",\n      value: function getDefaultOptions() {\n        return this.defaultOptions;\n      }\n    }, {\n      key: \"setDefaultOptions\",\n      value: function setDefaultOptions(t) {\n        this.defaultOptions = t;\n      }\n    }, {\n      key: \"setQueryDefaults\",\n      value: function setQueryDefaults(t, e) {\n        var s = this.queryDefaults.find(function (e) {\n          return b(t) === b(e.queryKey);\n        });\n        s ? s.defaultOptions = e : this.queryDefaults.push({\n          queryKey: t,\n          defaultOptions: e\n        });\n      }\n    }, {\n      key: \"getQueryDefaults\",\n      value: function getQueryDefaults(t) {\n        if (!t) return;\n        var e = this.queryDefaults.find(function (e) {\n          return g(t, e.queryKey);\n        });\n        return null == e ? void 0 : e.defaultOptions;\n      }\n    }, {\n      key: \"setMutationDefaults\",\n      value: function setMutationDefaults(t, e) {\n        var s = this.mutationDefaults.find(function (e) {\n          return b(t) === b(e.mutationKey);\n        });\n        s ? s.defaultOptions = e : this.mutationDefaults.push({\n          mutationKey: t,\n          defaultOptions: e\n        });\n      }\n    }, {\n      key: \"getMutationDefaults\",\n      value: function getMutationDefaults(t) {\n        if (!t) return;\n        var e = this.mutationDefaults.find(function (e) {\n          return g(t, e.mutationKey);\n        });\n        return null == e ? void 0 : e.defaultOptions;\n      }\n    }, {\n      key: \"defaultQueryOptions\",\n      value: function defaultQueryOptions(t) {\n        if (null != t && t._defaulted) return t;\n\n        var e = _objectSpread({}, this.defaultOptions.queries, this.getQueryDefaults(null == t ? void 0 : t.queryKey), t, {\n          _defaulted: !0\n        });\n\n        return !e.queryHash && e.queryKey && (e.queryHash = m(e.queryKey, e)), void 0 === e.refetchOnReconnect && (e.refetchOnReconnect = \"always\" !== e.networkMode), void 0 === e.useErrorBoundary && (e.useErrorBoundary = !!e.suspense), e;\n      }\n    }, {\n      key: \"defaultMutationOptions\",\n      value: function defaultMutationOptions(t) {\n        return null != t && t._defaulted ? t : _objectSpread({}, this.defaultOptions.mutations, this.getMutationDefaults(null == t ? void 0 : t.mutationKey), t, {\n          _defaulted: !0\n        });\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.queryCache.clear(), this.mutationCache.clear();\n      }\n    }]);\n\n    return _class3;\n  }(), t.QueryClientProvider = function (_ref9) {\n    var t = _ref9.client,\n        e = _ref9.children,\n        s = _ref9.context,\n        _ref9$contextSharing = _ref9.contextSharing,\n        r = _ref9$contextSharing === void 0 ? !1 : _ref9$contextSharing;\n    i.useEffect(function () {\n      return t.mount(), function () {\n        t.unmount();\n      };\n    }, [t]);\n    var n = ut(s, r);\n    return i.createElement(ot.Provider, {\n      value: !s && r\n    }, i.createElement(n.Provider, {\n      value: t\n    }, e));\n  }, t.QueryErrorResetBoundary = function (_ref10) {\n    var t = _ref10.children;\n\n    var _i$useState3 = i.useState(function () {\n      return ft();\n    }),\n        _i$useState4 = _slicedToArray(_i$useState3, 1),\n        e = _i$useState4[0];\n\n    return i.createElement(pt.Provider, {\n      value: e\n    }, \"function\" == typeof t ? t(e) : t);\n  }, t.QueryObserver = V, t.defaultContext = at, t.dehydrate = function (t) {\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var s = [],\n        r = [];\n\n    if (!1 !== e.dehydrateMutations) {\n      var _r3 = e.shouldDehydrateMutation || rt;\n\n      t.getMutationCache().getAll().forEach(function (t) {\n        _r3(t) && s.push(function (t) {\n          return {\n            mutationKey: t.options.mutationKey,\n            state: t.state\n          };\n        }(t));\n      });\n    }\n\n    if (!1 !== e.dehydrateQueries) {\n      var _s6 = e.shouldDehydrateQuery || it;\n\n      t.getQueryCache().getAll().forEach(function (t) {\n        _s6(t) && r.push(function (t) {\n          return {\n            state: t.state,\n            queryKey: t.queryKey,\n            queryHash: t.queryHash\n          };\n        }(t));\n      });\n    }\n\n    return {\n      mutations: s,\n      queries: r\n    };\n  }, t.focusManager = M, t.hashQueryKey = b, t.hydrate = nt, t.isCancelledError = I, t.isError = function (t) {\n    return t instanceof Error;\n  }, t.notifyManager = K, t.onlineManager = w, t.parseFilterArgs = f, t.parseMutationArgs = d, t.parseMutationFilterArgs = p, t.parseQueryArgs = l, t.useHydrate = bt, t.useInfiniteQuery = function (t, e, s) {\n    return mt(l(t, e, s), et);\n  }, t.useIsFetching = function (t, e, r) {\n    var _f17 = f(t, e, r),\n        _f18 = _slicedToArray(_f17, 2),\n        n = _f18[0],\n        _f18$ = _f18[1],\n        a = _f18$ === void 0 ? {} : _f18$,\n        o = ct({\n      context: a.context\n    }),\n        u = o.getQueryCache();\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return u.subscribe(K.batchCalls(t));\n    }, [u]), function () {\n      return o.isFetching(n);\n    }, function () {\n      return o.isFetching(n);\n    });\n  }, t.useIsMutating = function (t, e, r) {\n    var _p = p(t, e, r),\n        _p2 = _slicedToArray(_p, 2),\n        n = _p2[0],\n        _p2$ = _p2[1],\n        a = _p2$ === void 0 ? {} : _p2$,\n        o = ct({\n      context: a.context\n    }),\n        u = o.getMutationCache();\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return u.subscribe(K.batchCalls(t));\n    }, [u]), function () {\n      return o.isMutating(n);\n    }, function () {\n      return o.isMutating(n);\n    });\n  }, t.useIsRestoring = lt, t.useMutation = function (t, e, r) {\n    var n = d(t, e, r),\n        a = ct({\n      context: n.context\n    }),\n        _i$useState5 = i.useState(function () {\n      return new st(a, n);\n    }),\n        _i$useState6 = _slicedToArray(_i$useState5, 1),\n        o = _i$useState6[0];\n\n    i.useEffect(function () {\n      o.setOptions(n);\n    }, [o, n]);\n    var u = s.useSyncExternalStore(i.useCallback(function (t) {\n      return o.subscribe(K.batchCalls(t));\n    }, [o]), function () {\n      return o.getCurrentResult();\n    }, function () {\n      return o.getCurrentResult();\n    }),\n        c = i.useCallback(function (t, e) {\n      o.mutate(t, e).catch(gt);\n    }, [o]);\n    if (u.error && vt(o.options.useErrorBoundary, [u.error])) throw u.error;\n    return _objectSpread({}, u, {\n      mutate: c,\n      mutateAsync: u.mutate\n    });\n  }, t.useQueries = function (_ref11) {\n    var t = _ref11.queries,\n        e = _ref11.context;\n\n    var r = ct({\n      context: e\n    }),\n        n = lt(),\n        a = i.useMemo(function () {\n      return t.map(function (t) {\n        var e = r.defaultQueryOptions(t);\n        return e._optimisticResults = n ? \"isRestoring\" : \"optimistic\", e;\n      });\n    }, [t, r, n]),\n        _i$useState7 = i.useState(function () {\n      return new tt(r, a);\n    }),\n        _i$useState8 = _slicedToArray(_i$useState7, 1),\n        o = _i$useState8[0],\n        u = o.getOptimisticResult(a);\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return n ? function () {} : o.subscribe(K.batchCalls(t));\n    }, [o, n]), function () {\n      return o.getCurrentResult();\n    }, function () {\n      return o.getCurrentResult();\n    }), i.useEffect(function () {\n      o.setQueries(a, {\n        listeners: !1\n      });\n    }, [a, o]), u;\n  }, t.useQuery = function (t, e, s) {\n    return mt(l(t, e, s), V);\n  }, t.useQueryClient = ct, t.useQueryErrorResetBoundary = yt, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}